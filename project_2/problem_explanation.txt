Project 2 Problem Explanation 
Sarayu Vijayanagaram

My approach to solving this problem involved using one function other than main to handle all the threads (player actions). I declared several constants for the maximum amount of players for each team as well as assigning integers to the type of sport to make implementing the logic easier. Also outside the functions, I initialized arrays for the players, conditional variables, and created locks for each type of sport. Note that I did not get to the rugby implementation of this project.
Starting in main, I initialized the locks and then created threads for each player, storing them in the thread array. After each thread is created using pthread_create, player_threads() is called using the (void*)[sport] argument. 
In player_threads(), lots of values are created and initialized such as the type of player, their number, a lock for them, and a conditional variable. The determined lock is then locked. Depending on the sport of the player, the function checks if the current number of players for the sport type has reached its maximum limit. If it has, then there is a conditional wait because the field is not safe to enter. The thread/player then goes to nap until another thread signals that it is safe to enter again. After the thread wakes up from the conditional wait, it increments the player count and assigns the player number. The player number is assigned into the array of players for that sport type so it is easy to keep track of the players on the field. Players start to enter the field and print statements are outputed. If a team is ready, another print statement is outputed. Similarly, if a game has started, a print statement is outputed. Before the game starts, the lock that was previously locked is unlocked. The sport is played for a random amount of time, and once the lock is locked, players leave the field, outputting print statements. A signal is then broadcasted to other players to notify them that the field is available again, and the lock is unlocked. 
Back in main, the program waits for all threads to finish. Then, the locks are destroyed.
The seed value I used to test the program was 456789 and is located in seed.txt.
